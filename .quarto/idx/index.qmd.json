{"title":"CASA0025 Interactive Application","markdown":{"headingText":"format: html","containsRefs":false,"markdown":"\n---\ntitle: \"CASA0025 Interactive Application\"  \nauthor: \"Zixing Guan, Ruoyun Yu, Siyi Li\"  \ndate: \"2025-04-25\"  \nbibliography: 25references.bib  \n\n# Urban Carbon Archives of China's Five Major Urban Agglomerations\n\n## Project Summary\n\nThe aim of this project is to develop an application to compare the gap between building carbon emissions and vegetation carbon absorption in China's five major urban agglomerations. This application can not only provide data support and decision-making references for China to achieve its 2060 “carbon neutrality” goal, but also assist researchers around the world in addressing global warming.\n\n### Problem Statement\n\nThe negative impact of global warming on the world continues to intensify [@Ahmad2022]. Since 2005, China has become the world's largest carbon emitter [@Zuo2022]. In response to this situation, China has proposed the goal of achieving \"carbon neutrality\" by 2060 [@Yang2022], which can be achieved through various strategies, including social and natural contributions. Among them, natural contributions mainly involve the carbon sequestration capacity of plant ecosystems [@AlKafy2023]. However, natural contributions alone cannot completely offset the $CO_{2}$ produced, and social support is needed to bridge the gap between carbon emissions and carbon absorption [@Wu2022]. In addition, as high-risk areas for ecological and environmental issues [@Liu2018], urban agglomerations are important responsible entities for achieving the above goals. As a result, the developed application aims to provide a visualization tool for quantifying the gap in “carbon neutrality” process, thereby providing a reference for the social contribution required to achieve “carbon neutrality”.\n\n### End User\n\nThis application is aimed at diverse user groups worldwide, including policy makers (e.g. environmental management officials), environmental researchers, corporate sustainability leaders, environmental non-governmental organizations, as well as investors and financial institutions (e.g. carbon finance product developers). These user groups collectively face an urgent need for accurate assessment of carbon emissions and absorption in urban agglomerations, requiring precise and visualized data to support their policy-making, academic research, corporate strategy, public education, and investment decisions. By providing detailed carbon balance analysis of urban agglomerations in China, this application can become a scientific and intuitive decision-making tool for professionals in different fields.\n\n### Data\n\nConsidering the high correlation between energy consumption and carbon emissions, nighttime light (NTL) data can be used to estimate the spatial distribution of carbon emissions [@Wang2024]. This project obtained the latest generation of nighttime light data NPP-VIIRS through GEE.\n\nThe carbon sequestration capacity of plant ecosystems has been proven to be an important force in reducing atmospheric carbon dioxide accumulation and mitigating climate change [@Legesse2024], so the net primary productivity (NPP) index of vegetation can serve as a proxy indicator for carbon absorption capacity [@Das2023]. The dataset for estimating carbon absorption obtained through GEE is shown in the table below. Considering the availability of NPP-VIIRS data, the comprehensive time span of the above types of data is from January 1, 2015 to December 31, 2023. Furthermore, the geographical boundary data of urban agglomerations is GADM data (version 4.1) [@gadm2022], and the population data is also obtained through the GEE platform.\n\n+------------------------------------------------------+-------------------------------+--------------+\n| Indicator                                            | Dataset                       | Time Span    |\n+======================================================+===============================+==============+\n| Net primary productivity index (NDVI)                | MODIS/061/MOD13A2             | 2015-2023    |\n+------------------------------------------------------+-------------------------------+--------------+\n| Evaporation and transpiration capacity               | MODIS/061/MOD16A2GF           | 2015-2020    |\n+------------------------------------------------------+-------------------------------+--------------+\n| Evaporation and transpiration capacity               | MODIS/061/MOD16A2             | 2021-2023    |\n+------------------------------------------------------+-------------------------------+--------------+\n| Precipitation, temperature, and short radiation data | NASA/FLDAS/NOAH01/C/GL/M/V001 | 2015-2023    |\n+------------------------------------------------------+-------------------------------+--------------+\n\n## Methodology\n\n#### Data preprocessing\n\nIn general, the raw data has been standardized and preprocessed through spatial cropping, missing value filling and smoothing, mask unification, and outlier processing, providing a high-quality data foundation for subsequent estimation of carbon emissions and carbon sequestration at the city scale and analysis of temporal changes.\n\nAfter data preprocessing, the main step is to estimate the specific carbon emissions and carbon absorption, and calculate the difference between the two, which is represented by the total amount of carbon dioxide.\n\n#### Carbon emissions\n\nThe estimation method of carbon emissions is improved based on the existing model [@yang2022] by considering the impact of urban area. Firstly, monthly average NTL data ($nW/pixel$) of cities within five major urban agglomerations were obtained using the NPP-VIIRS dataset. Then, based on converting the NTL data into $nW$ per m², calculate the total NTL intensity ($nW$) for each city using the following formula.\n\n$$\nNTL_{\\text{m²}} = \\frac{NTL_{\\text{pixel}}}{10^4} \\times \\pi\n$$\n\n$$\n  NTL_{total} = NTL_{m^2} \\times A_{city}  \n$$\n\nwhere,\n\n$NTL_{total}$: the total NTL intensity of the city (nW);\n\n$NTL_{pixel}$: the monthly average nighttime light data for each pixel (nW/cm²/sr);\n\n$NTL_{m^2}$: : the monthly average nighttime light data for each m\\^2 (nW/m²);\n\n$A_{city}$: the area of the city (m²).\n\nNext, based on the region where the city is located (eastern/central/western), different linear transformation formulas (as shown in the table below) will be used to calculate the total carbon emissions of the city.\n\n+-------------+-----------------------------------------------------------------+--------------------------------------------------------------------+\n| **Region**  | **Province**                                                    | **Formula**                                                        |\n+-------------+-----------------------------------------------------------------+--------------------------------------------------------------------+\n| Western     | Sichuan, Chongqing                                              | $$   NC = \\log(NTL_{total}) \\times 0.3645 + (V_{it} + 2.2189)   $$ |\n+-------------+-----------------------------------------------------------------+--------------------------------------------------------------------+\n| Central     | Anhui; Hubei, Hunan, Jiangxi                                    | $$   NC = \\log(NTL_{total}) \\times 1.0484 + (V_{it} - 6.1871)   $$ |\n+-------------+-----------------------------------------------------------------+--------------------------------------------------------------------+\n| Eastern     | Beijing, Tianjin, Hebei; Shanghai, Jiangsu, Zhejiang; Guangdong | $$   NC = \\log(NTL_{total}) \\times 0.8773 + (V_{it} - 4.2414)   $$ |\n+-------------+-----------------------------------------------------------------+--------------------------------------------------------------------+\n\nwhere,\n\n$NC$: $CO_{2}$ emission amount (10k tons);\n\n$NTL_{total}$: the total NTL intensity of the city (nW);\n\n$V_{it}$: fixed impact value (see the table below).\n\n+----------------+------------------------------+----------------+\n| Region         | Province                     | Vit            |\n+================+==============================+================+\n| Western        | Sichuan                      | 0.4006         |\n+----------------+------------------------------+----------------+\n|                | Chongqing                    | -0.0131        |\n+----------------+------------------------------+----------------+\n| Central        | Anhui; Hubei, Hunan, Jiangxi | /              |\n+----------------+------------------------------+----------------+\n| Eastern        | Beijing                      | 1.2970         |\n+----------------+------------------------------+----------------+\n|                | Tianjin                      | 0.7509         |\n+----------------+------------------------------+----------------+\n|                | Hebei                        | -0.2134        |\n+----------------+------------------------------+----------------+\n|                | Shanghai                     | 1.0254         |\n+----------------+------------------------------+----------------+\n|                | Jiangsu                      | -0.6130        |\n+----------------+------------------------------+----------------+\n|                | Zhejiang                     | -0.4030        |\n+----------------+------------------------------+----------------+\n|                | Guangdong                    | -0.3258        |\n+----------------+------------------------------+----------------+\n\n#### Carbon sequestration\n\nAs for carbon sequestration, this project refers to The Carnegie-Ames-Stanford approach (CASA) Biosphere model [@Potter1993]. The calculation method is based on the carbon absorption related datasets obtained from the GEE platform to estimate carbon absorption. The calculation formula for NPP is as follows.\n\n$$NPP=PAR\\times FPAR\\times\\epsilon$$\n\nwhere,\n\n+-------------------------------------------------------------+---------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+\n| Parameter                                                   | Formula                                                                               | Explanation                                                                      |\n+=============================================================+=======================================================================================+==================================================================================+\n| PAR (Photosynthetically Active Radiation)                   | $$   PAR = Swnet\\_tavg \\times 0.5 \\times \\left(\\frac{30\\,\\text{days}}{106}\\right)  $$ | where,                                                                           |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | $Swnet\\_tavg$: The average value of shortwave net radiation (MJ$/m^2/month$)     |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | $0.5$: Proportion of photosynthetically active radiation in shortwave radiation; |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | Convert the results to a monthly scale.                                          |\n+-------------------------------------------------------------+---------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+\n| FPAR (Photosynthetically Active Radiation Absorption Ratio) | $$  FPAR = \\frac{SR - SR_{min}}{SR_{max} - SR_{min}}  $$                              | where,                                                                           |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             | $$     SR = \\frac{NDVI + 1}{1 - NDVI}     $$                                          | $SR$: Reflectance;                                                               |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | $NDVI$: the Normalized Difference Vegetation Index;                              |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | $SR_{max}$ and $SR_{min}$: The minimum and maximum values of $SR$.               |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             |                                                                                       | The value of $FPAR$ is restricted between 0 and 0.95.                            |\n+-------------------------------------------------------------+---------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+\n| $\\epsilon$ (Energy Conversion Efficiency)                   | $$\\epsilon = Te1 \\times Te2 \\times WE \\times 0.95 $$                                  | where,                                                                           |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             | $$   Te1 = 0.8 + 0.027T - 0.00005T^2   $$                                             | $T$: Temperature (typically in °C);                                              |\n|                                                             |                                                                                       |                                                                                  |\n|                                                             | $$ Te2 = \\frac{1.184}{1 + e^{-0.2(T-10)} + e^{0.3(T+10)}} $$                          | $WE$: Water Use Efficiency.                                                      |\n+-------------------------------------------------------------+---------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+\n\nBecause the NPP calculated by the above formula is in units of carbon, it needs to be converted into an amount in units of carbon dioxide using the following formula.\n\n$$S_{CO_2}=NPP\\times\\frac{44}{12}$$\n\nwhere,\n\n$S_{CO_2}$: Carbon dioxide sequestration capacity of plants (g $CO_{2}$/m²);\n\n$NPP$: Net primary productivity of plants (g $C$/m²);\n\n$\\frac{44}{12}$: This is a conversion factor derived from the molecular weight ratio of carbon dioxide (CO₂) to carbon (C).\n\nFinally, the total carbon sequestration amount needs to be obtained by considering the urban area (see formula below).\n\n$$\nTCS=S_{CO_2}\\times A_{city}\n$$\n\nwhere,\n\n$TCS$: total carbon dioxide sequestration amount (10k tons);\n\n$S_{CO_2}$: Carbon dioxide sequestration capacity of plants (g $CO_{2}$/m²);\n\n$A_{city}$: the area of the city (m²).\n\nAfter calculating the total amount of carbon dioxide emissions and carbon sequestration , the net carbon dioxide emissions can be obtained through the following formula.\n\n$$\nNC_{CO_2}=NC-TCS\n$$\n\nwhere,\n\n$NC_{CO_2}$: Net $CO_{2}$ emissions (10k tons);\n\n$NC$: $CO_{2}$ emissions (10k tons);\n\n$TCS$: total $CO_{2}$ sequestration amount (10k tons).\n\n## Interface\n\nHere are several key components of the application interface:\n\n1.  **Custom spatio-temporal range**：On the left side of the main interface of the application, an interactive dashboard is displayed, where users can select different years, months, urban agglomerations, provinces, and cities according to their needs. After clicking the corresponding load button, the interactive map in the middle will display the layer of the selected area. Through this customized dashboard, users can quickly select research areas of interest.\n\n2.  **Interactive map**: The middle part of the application interface will provide an interactive map, where users can zoom in and out to view specific areas. Additionally, at the top of the interface, users can view the map in a targeted manner by selecting different layers (as shown in the table below) based on their research interests. In addition, users can click on any city area to view the layers.\n\n    +--------------+-------------------------------------------------------------+\n    | Layer        | Indicator                                                   |\n    +==============+=============================================================+\n    | 1            | CO₂ NetEmissions                                            |\n    +--------------+-------------------------------------------------------------+\n    | 2            | CO₂ Emissions                                               |\n    +--------------+-------------------------------------------------------------+\n    | 3            | CO₂ Sequestration                                           |\n    +--------------+-------------------------------------------------------------+\n    | 4            | Nighttime Light                                             |\n    +--------------+-------------------------------------------------------------+\n    | 5            | FPAR (Photosynthetically Active Radiation Absorption Ratio) |\n    +--------------+-------------------------------------------------------------+\n    | 6            | Epsilon (Energy Conversion Effciency)                       |\n    +--------------+-------------------------------------------------------------+\n    | 7            | NPP (Net Carbon Sequestration)                              |\n    +--------------+-------------------------------------------------------------+\n    | 8            | WE (Water Use Effciency)                                    |\n    +--------------+-------------------------------------------------------------+\n\n3.  **Visual charts**: After the user selects urban agglomeration, province, city, and specific indicator on the left panel and clicks the corresponding button to load them, the dashboard on the right side of the application interface will display visual charts. They are line chart comparing monthly changes in CO₂ emissions, sequestration, and net emissions; Line chart of monthly changes in multiple indicators, as well as a pie chart of the proportion of annual net CO₂ emissions of each city in its urban agglomeration. These charts can help users understand data in a visual way.\n\n## The Application\n\n::: column-page\n<iframe src=\"https://ruoyun2025.projects.earthengine.app/view/urban-carbon-archives-of-chinas-five-major-urban-agglomeration\" width=\"120%\" height=\"800px\">\n\n</iframe>\n:::\n\n## How it Works\n\n### **1.** Data Import and Preliminary Processing\n\nThis section loads the city list (UG_list) and Chinese city boundary data (gadm41_CHN_2hp). By matching provinces and city names, the city boundaries of the five major urban agglomerations in China are extracted, and attributes such as *region* and $V_{it}$ value are attached. In addition, the researchers loaded VIIRS nighttime light data as the basis for subsequent CO₂ emissions estimates. However, only preliminary data import is carried out at this stage, and more remote sensing data such as meteorology and vegetation data will be imported in subsequent analysis steps to further calculate carbon sequestration and its key indicators.\n\n``` javascript\n// ====================== Loading and processing data ======================\nvar selectedCitiesTable = ee.FeatureCollection('projects/ee-siyili/assets/UG_list');\nvar allChinaCities = ee.FeatureCollection(\"projects/ee-siyili/assets/gadm41_CHN_2_shp\")\n  .filter(ee.Filter.eq(\"COUNTRY\", \"China\"));\n\n// Match the urban list with the national boundaries\nvar matchedCities = selectedCitiesTable.map(function(row) {\n  var city = row.getString(\"city\");\n  var province = row.getString(\"province\"); \n\n  var matches = allChinaCities.filter(ee.Filter.and(\n    ee.Filter.eq(\"NAME_1\", province),\n    ee.Filter.eq(\"NAME_2\", city)\n  ));\n\n  var mergedGeom = ee.FeatureCollection(matches).union().geometry();\n  var count = matches.size();\n\n// Extract other attribute information\nvar region = row.getString(\"region\");\nvar Vit = row.getNumber(\"Vit\");\nvar urbanAgg = row.getString(\"UrbanAgg\");\n\nreturn ee.Feature(mergedGeom).set({\n  'NAME_2': city,\n  'NAME_1': province,\n  'region': region,\n  'Vit': Vit,\n  'UrbanAgg': urbanAgg,\n  'match_count': count\n});\n}).filter(ee.Filter.gt('match_count', 0));\n\n// Load base image dataset\nvar dataset = ee.ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')  \n                .filterDate('2014-01-01', '2023-12-31');  // VIIRS monthly nighttime light Dataset\n```\n\n### **2.** Interface and Interactive Controls Design\n\nThis section aims to built an interactive interface, including the main map (MyMap), status prompt bar, chart panel, and various selectors, supporting flexible filtering of year, month, urban agglomeration, province, city, and indicators. Simultaneously, it also provides a clear button and 3 load data buttons to dynamically update maps and charts. The interface facilitates users to quickly locate or switch cities, provinces, and urban agglomerations.\n\n``` javascript\n// ====================== Map and interface initialisation ======================\nvar MyMap = ui.Map();\n\nvar statusLabel = ui.Label('Waiting for the operation...'); // Real-time display of operation progress\n\nvar indicatorChartWidget = null;\n\nfunction updateStatus(msg) {\n  statusLabel.setValue(msg);\n}\n\nMyMap.addLayer(matchedCities.style({color: 'gray', fillColor: '00000000'}), {}, 'urban boundary');\nMyMap.setCenter(104, 30, 5);\n\n// =============== Legend panel ================\nvar allLegendPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {\n    position: 'bottom-left',\n    padding: '8px',\n    backgroundColor: 'rgba(255,255,255,0.8)',\n    width: '500px',\n    maxHeight: '115px',\n    whiteSpace: 'nowrap', \n  }\n});\nMyMap.add(allLegendPanel);\n\n// Generate legends for each layer\nfunction createLegendBox(title, palette, min, max) {\n  var titleLabel = ui.Label({\n    value: title,\n    style: {fontWeight: 'bold', fontSize: '12px', margin: '2px 4px'}\n  });\n\n  var colorBar = ui.Thumbnail({\n    image: ee.Image.pixelLonLat().select(0)\n      .multiply((max - min) / 100.0).add(min),\n    params: {\n      bbox: [0, 0, 100, 1],\n      dimensions: '100x10',\n      format: 'png',\n      min: min,\n      max: max,\n      palette: palette\n    },\n    style: {stretch: 'horizontal', margin: '4px 0'}\n  });\n\n  var numTicks = 2;\n  var step = (max - min) / (numTicks - 1);\n\n  var tickLabels = [];\n  for (var i = 0; i < numTicks; i++) {\n    var value = (min + i * step).toFixed(0);\n    tickLabels.push(ui.Label(value, {\n      margin: '0 2px',\n      textAlign: 'center',\n      stretch: 'horizontal'\n    }));\n  }\n\n  var labelRow = ui.Panel({\n    widgets: tickLabels,\n    layout: ui.Panel.Layout.flow('horizontal'),\n    style: {stretch: 'horizontal'}\n  });\n\n  var box = ui.Panel({\n    widgets: [titleLabel, colorBar, labelRow],\n    style: {\n      margin: '0 10px',\n      width: '120px'\n    }\n  });\n\n  return box;\n}\n\n// =============== UI control design ================\nvar currentCityName = null;\n\n// Creating a year selector\nvar yearSelect = ui.Select({\n  items: ['2014', '2015', '2016', '2017','2018', '2019', '2020','2021', '2022', '2023'],\n  value: '2023',\n  placeholder: 'Select Year'\n});\n\n// Creating a month selector\nvar monthSlider = ui.Slider({\n  min: 0, // 0 for the whole year\n  max: 12,\n  step: 1,\n  value: 0,\n  style: {stretch: 'horizontal'},\n  onChange: function(month) {\n  if (currentCityName !== null) {\n    chartPanel.clear();\n    var cityFeature = matchedCities.filter(ee.Filter.eq('NAME_2', currentCityName)).first();\n\n    cityFeature.evaluate(function(f) {\n      if (f) {\n        var cityGeom = ee.Feature(f).geometry();\n        var selectedYear = yearSelect.getValue();\n\n        updateMap(selectedYear, cityGeom, month);\n        plotSinglecityCarbonChart(currentCityName, cityGeom, parseInt(selectedYear), month)\n        .then(function() {\n          plotCityIndicatorChart(currentCityName, cityGeom, parseInt(selectedYear), indicatorSelect.getValue());\n        });\n        updateStatus('Select Month：' + month);\n      } else {\n        updateStatus('No city information found');\n      }\n    });\n  }\n}\n});\n\nvar monthLabel = ui.Label('Please select month (0 = all year)');\n\nvar monthTipLabel = ui.Label({\n  value: 'Slide to update month selection',\n  style: {color: 'gray', fontSize: '11px', margin: '4px 0 8px 8px'}\n});\n\n// Creating a clear button\nvar clearButton = ui.Button({\n  label: 'Clear Selection',\n  onClick: function() {\n    currentCityName = null;\n    \n    var layers = MyMap.layers();\n  while (layers.length() > 0) {\n    layers.remove(layers.get(0));\n  }\n  \n    MyMap.addLayer(matchedCities.style({color: 'gray', fillColor: '00000000'}), {}, 'urban boundary');\n\n    allLegendPanel.clear();\n    chartPanel.clear();\n    urbanAggSelect.setValue(null);\n    provinceSelect.items().reset([]);\n    provinceSelect.setValue(null);\n    citySelect.items().reset([]);\n    citySelect.setValue(null);\n    updateStatus('City selection has been cleared. Please select again.');\n  }\n});\n\n// Creating a city selector\nvar urbanAggSelect = ui.Select({placeholder: 'Select Urban Agglomeration'});\nvar provinceSelect = ui.Select({placeholder: 'Select Province'});\nvar citySelect = ui.Select({placeholder: 'Select City'});\n\nvar urbanAggList = [\n  'Beijing-Tianjin-Hebei',\n  'Yangtze River Delta',\n  'Pearl River Delta',\n  'Middle Yangtze River',\n  'Chengdu-Chongqing'\n];\nurbanAggSelect.items().reset(urbanAggList);\n\n// Urban Agglomeration\nurbanAggSelect.onChange(function(urbanAgg) {\n  var provinces = matchedCities\n    .filter(ee.Filter.eq('UrbanAgg', urbanAgg))\n    .aggregate_array('NAME_1')\n    .distinct()\n    .sort();\n\n  provinces.evaluate(function(provinceList) {\n    provinceSelect.items().reset(provinceList);\n    provinceSelect.setValue(null);\n    citySelect.items().reset([]);\n    citySelect.setValue(null);\n  });\n\n  if (urbanAgg) {\n    var urbanAggCities = matchedCities.filter(ee.Filter.eq('UrbanAgg', urbanAgg));\n    var urbanAggGeometry = urbanAggCities.geometry();\n\n    var layers = MyMap.layers();\n    while (layers.length() > 0) {\n      layers.remove(layers.get(0));\n    }\n\n    MyMap.addLayer(matchedCities.style({color: 'gray', fillColor: '00000000'}), {}, 'urban boundary');\n    MyMap.addLayer(urbanAggCities.style({\n      color: 'blue',\n      fillColor: '0000FF33',\n      width: 2\n    }), {}, 'Selected Urban Agglomeration');\n\n    MyMap.centerObject(urbanAggGeometry, 6);\n    updateStatus('Selected Urban Agglomeration：' + urbanAgg);\n  }\n});\n\n// Province\nprovinceSelect.onChange(function(province) {\n  var urbanAgg = urbanAggSelect.getValue();\n\n  var cities = matchedCities\n    .filter(ee.Filter.and(\n      ee.Filter.eq('UrbanAgg', urbanAgg),\n      ee.Filter.eq('NAME_1', province)\n    ))\n    .aggregate_array('NAME_2')\n    .distinct()\n    .sort();\n\n  cities.evaluate(function(cityList) {\n    citySelect.items().reset(cityList);\n    citySelect.setValue(null);\n  });\n\n  if (urbanAgg && province) {\n    var provinceCities = matchedCities.filter(ee.Filter.and(\n      ee.Filter.eq('UrbanAgg', urbanAgg),\n      ee.Filter.eq('NAME_1', province)\n    ));\n    var provinceGeometry = provinceCities.geometry();\n\n    var layers = MyMap.layers();\n    while (layers.length() > 0) {\n      layers.remove(layers.get(0));\n    }\n\n    MyMap.addLayer(matchedCities.style({color: 'gray', fillColor: '00000000'}), {}, 'urban boundary');\n    MyMap.addLayer(provinceCities.style({\n      color: 'green',\n      fillColor: '00FF0033',\n      width: 2\n    }), {}, 'Selected Province');\n\n    MyMap.centerObject(provinceGeometry, 7);\n    updateStatus('Selected Province：' + province);\n  }\n});\n\n// City\ncitySelect.onChange(function(city) {\n  var urbanAgg = urbanAggSelect.getValue();\n  var province = provinceSelect.getValue();\n\n  if (urbanAgg && province && city) {\n    currentCityName = city;\n\n    var cityFeature = matchedCities.filter(ee.Filter.and(\n      ee.Filter.eq('UrbanAgg', urbanAgg),\n      ee.Filter.eq('NAME_1', province),\n      ee.Filter.eq('NAME_2', city)\n    )).first();\n\n    cityFeature.evaluate(function(f) {\n      if (f) {\n        var cityGeom = ee.Feature(f).geometry();\n\n        var layers = MyMap.layers();\n        while (layers.length() > 0) {\n          layers.remove(layers.get(0));\n        }\n\n        MyMap.addLayer(matchedCities.style({\n          color: 'gray',\n          fillColor: '00000000'\n        }), {}, 'urban boundary');\n\n        MyMap.addLayer(ee.FeatureCollection(ee.Feature(f)).style({\n          color: 'red',\n          fillColor: 'FF000033',\n          width: 2\n        }), {}, 'Selected City');\n\n        MyMap.centerObject(cityGeom, 7);\n        updateStatus('Selected Province：' + city + ' (Click \"Load City Data\" to view the layer.)');\n      } else {\n        updateStatus('No city information found');\n      }\n    });\n  }\n});\n\n// Creating an indicator selector\nvar indicatorSelect = ui.Select({\n  items: [\n    {label: 'Net Carbon Sequestration', value: 'NPP'},\n    {label: 'WE (Water Use Effciency)', value: 'WE'},\n    {label: 'FPAR (Photosynthetically Active Radiation Absorption Ratio)', value: 'FPAR'},\n    {label: 'Energy Conversion Effciency', value: 'Epsilon'},\n    {label: 'Carbon Emission (CO₂)', value: 'Emission'},\n    {label: 'Carbon Sequestration (CO₂)', value: 'CO2Absorption'},\n    {label: 'Precipitation', value: 'Rain'},\n    {label: 'T (Temperature)', value: 'Temperature'},\n    {label: 'PAR (Photosynthetically Active Radiation)', value: 'PAR'}\n  ],\n  value: 'NPP',\n  placeholder: 'select an indicator'\n});\n\nindicatorSelect.onChange(function(indicator) {\n  if (currentCityName !== null) {\n    if (indicatorChartWidget !== null) {\n      chartPanel.remove(indicatorChartWidget);\n      indicatorChartWidget = null;\n    }\n\n    var cityFeature = matchedCities.filter(ee.Filter.eq('NAME_2', currentCityName)).first();\n    cityFeature.evaluate(function(f){\n      if (f) {\n        var cityGeom = ee.Feature(f).geometry();\n        var selectedYear = yearSelect.getValue();\n        var selectedMonth = monthSlider.getValue();\n\n        indicatorChartWidget = plotCityIndicatorChart(currentCityName, cityGeom, parseInt(selectedYear), indicator);\n      }\n    });\n  }\n});\n\nvar indicatorTipLabel = ui.Label({\n  value: 'Update will be shown in the last chart.',\n  style: {\n    fontSize: '11px',\n    color: 'gray',\n    margin: '0 0 4px 10px',\n    padding: '0'\n  }\n});\n\n// \"Load Urban Agglomeration Data\" button\nvar loadUrbanAggButton = ui.Button({\n  label: 'Load Urban Agglomeration Data',\n  onClick: function() {\n    var urbanAgg = urbanAggSelect.getValue();\n    var year = yearSelect.getValue();\n    if (urbanAgg) {\n      chartPanel.clear();\n      var urbanAggCities = matchedCities.filter(ee.Filter.eq('UrbanAgg', urbanAgg));\n      var urbanAggGeometry = urbanAggCities.geometry();\n\n      plotUrbanAgglomerationCarbonChart(urbanAgg, urbanAggGeometry, parseInt(year));\n\n      updateStatus('Loading Urban Agglomeration: ' + urbanAgg);\n    } else {\n      updateStatus('Please select an urban agglomeration.');\n    }\n  }\n});\n\n\n//“Load Provicne Data” button\nvar loadProvinceButton = ui.Button({\n  label: 'Load Province Data',\n  onClick: function() {\n    var urbanAgg = urbanAggSelect.getValue();\n    var province = provinceSelect.getValue();\n    var year = yearSelect.getValue();\n    if (urbanAgg && province) {\n      chartPanel.clear();\n      var provinceGeom = matchedCities.filter(ee.Filter.and(\n        ee.Filter.eq('UrbanAgg', urbanAgg),\n        ee.Filter.eq('NAME_1', province)\n      )).geometry();\n\n      plotProvinceCarbonChart(province, provinceGeom, parseInt(year));\n\n      updateStatus('Loading Province: ' + province);\n    } else {\n      updateStatus('Please select urban agglomeration and province first.');\n    }\n  }\n});\n\n// \"Load City Data\" button\nvar loadFromSelectButton = ui.Button({\n  label: 'Load City Data',\n  onClick: function() {\n    var urbanAgg = urbanAggSelect.getValue();\n    var province = provinceSelect.getValue();\n    var city = citySelect.getValue();\n    var year = yearSelect.getValue();\n    var month = monthSlider.getValue();\n\n    if (urbanAgg && province && city) {\n      chartPanel.clear();\n      currentCityName = city;\n      var cityGeom = matchedCities.filter(ee.Filter.and(\n        ee.Filter.eq('UrbanAgg', urbanAgg),\n        ee.Filter.eq('NAME_1', province),\n        ee.Filter.eq('NAME_2', city)\n      )).first().geometry();\n\n      updateMap(year, cityGeom, month);\n      plotSinglecityCarbonChart(city, cityGeom, parseInt(year), month)\n      .then(function() {\n  indicatorChartWidget = plotCityIndicatorChart(city, cityGeom, parseInt(year), indicatorSelect.getValue());\n  updateStatus('Loading City: ' + city);\n      });\n    } else {\n      updateStatus('Please select an urban agglomeration, province, and city.');\n    }\n  }\n});\n\n// Integrate controls into panels\nvar controls = ui.Panel({\n  widgets: [\n    ui.Label('Please select year'), \n    yearSelect,\n    monthLabel,\n    monthSlider,\n    monthTipLabel,\n    clearButton,\n    ui.Label('Please select an urban agglomeration'),\n    urbanAggSelect, \n    loadUrbanAggButton,\n    ui.Label('Please select a province'),\n    provinceSelect,\n    loadProvinceButton,\n    ui.Label('Please select a city'),\n    citySelect,\n    ui.Label('Please select an indicator'),\n    indicatorSelect,\n    indicatorTipLabel,\n    loadFromSelectButton\n  ],\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {\n    margin: '4px',\n    padding: '4px'\n  }\n});\n\nvar sidebar = ui.Panel({\n  widgets: [\n    statusLabel,\n    controls\n  ],\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {\n    width: '290px',\n    position: 'bottom-left'\n  }\n});\n\n// Define the right chart panel\nvar chartPanel = ui.Panel({  \n  layout: ui.Panel.Layout.flow('vertical'),  \n  style: {  \n    position: 'top-right',  \n    width: '300px',    \n    height: '900',    \n    padding: '10px',  \n    backgroundColor: 'rgba(255, 255, 255, 0.8)',  \n    border: '1px solid black'  \n  }  \n});  \nui.root.insert(1, chartPanel);  \n\n// Clear the interface again\nui.root.clear();\n\n// Add a sidebar \nui.root.add(sidebar); \n\n// Add Map (MyMap)\nui.root.add(MyMap);\n\n// Add chart area\nui.root.add(chartPanel);\n\n// =============== Map click interaction ================\n// Event Listener\nMyMap.onClick(function(coords) {\n  var point = ee.Geometry.Point(coords.lon, coords.lat);\n  var clickedFeature = matchedCities.filterBounds(point).first();\n\n//Selecting City Event\n  clickedFeature.evaluate(function(f) {\nif (f) {\n  chartPanel.clear();\n      var cityName = f.properties.NAME_2;\n      currentCityName = cityName;\n      var cityGeom = matchedCities.filter(ee.Filter.eq(\"NAME_2\", cityName)).first().geometry();\n      var selectedYear = yearSelect.getValue();\n      var selectedMonth = monthSlider.getValue();\n      \n      updateMap(selectedYear, cityGeom, selectedMonth);\n      plotSinglecityCarbonChart(cityName, cityGeom, parseInt(selectedYear), selectedMonth)\n      .then(function() {\n        indicatorChartWidget = plotCityIndicatorChart(cityName, cityGeom, parseInt(selectedYear), indicatorSelect.getValue());\n        updateStatus('Click on the city: ' + cityName);\n      });\n    } else {\n      updateStatus('No city selected');\n    }\n  });\n});\n\n// Processing the selected year event\nyearSelect.onChange(function(year) {\n  if (currentCityName !== null) {\n    chartPanel.clear();\n    var cityFeature = matchedCities.filter(ee.Filter.eq('NAME_2', currentCityName)).first();\n\n    cityFeature.evaluate(function(f) {\n      if (f) {\n        var cityGeom = ee.Feature(f).geometry();\n        var selectedMonth = monthSlider.getValue();\n\n        updateMap(year, cityGeom, selectedMonth);\n        plotSinglecityCarbon(currentCityName, cityGeom, parseInt(year), selectedMonth);\n        plotCityIndicatorChart(currentCityName, cityGeom, parseInt(year), indicatorSelect.getValue());\n        updateStatus('Year switching: ' + year);\n      } else {\n        updateStatus('City information not found');\n      }\n    });\n  }\n});\n```\n\n### **3.** Data Processing and Analysis\n\nIn this section, the researchers combine the city, year, and month parameters to dynamically extract and process nighttime light, meteorological, and vegetation related data, completing the calculation of core indicators such as CO₂ emissions, CO₂ sequestration, and net CO₂ emissions. The specific calculation method has been explained in detail in the Methodology section above.\n\n``` javascript\n// =============== Main plotting function ================\n// Set visualization parameters\nvar viirsVis = {\n  min: 0.0,\n  max: 50.0,\n  palette: [\n    'black','darkblue','blue','purple',\n    'cyan','green','yellow','white'\n  ]\n};\n\nvar ncVis = {\n  min: 0,\n  max: 10000,\n  palette: ['green','yellow','red']\n};\n\n// Fuction of carbon emissions\nvar computeNCitj = function(feature) {\n  var region = feature.getString('region');\n  var DN     = ee.Number(feature.get('averageDNitj'));\n  var Vit    = ee.Number(feature.get('Vit'));\n\n  return ee.Algorithms.If(\n    DN.lte(0),\n    feature,\n    (function() {\n      var log_DN = DN.log();\n      var log_NCitj = ee.Algorithms.If(\n        region.equals('eastern'),\n        log_DN.multiply(1.0484).add(Vit.subtract(6.1871)),\n        ee.Algorithms.If(\n          region.equals('central'),\n          log_DN.multiply(0.8773).subtract(4.2414),\n          ee.Algorithms.If(\n            region.equals('western'),\n            log_DN.multiply(0.3645).add(Vit.add(2.2189)),\n            null\n          )\n        )\n      );\n      return feature.set('NCitj', ee.Number(log_NCitj).exp());\n    })()\n  );\n};\n\n// Update the display content of the map\nfunction updateMap(year, geometry, month) {\n  var layers = MyMap.layers();\nwhile (layers.length() > 0) {\n  layers.remove(layers.get(0));\n}\n  allLegendPanel.clear();\n  \n  var startDate, endDate;\n  if (month === 0) {\n    startDate = ee.Date.fromYMD(parseInt(year), 1, 1);\n    endDate = ee.Date.fromYMD(parseInt(year), 12, 31);\n  } else {\n    var monthInt = parseInt(month);  \n    startDate = ee.Date.fromYMD(parseInt(year), monthInt, 1);\n    endDate = startDate.advance(1, 'month');\n  }\n  MyMap.addLayer(matchedCities.style({color: 'gray', fillColor: '00000000'}), {}, 'Boundary of the research area');\n\n//  Nighttime Light Image Collection (year)\n  var viirs = ee.ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')\n    .filterDate(startDate, endDate)\n    .select('avg_rad')         // Select the average emissivity band\n    .mean()   \n    .clip(geometry);\n\n// Layer (year)\nvar cityFeature = matchedCities.filterBounds(geometry).first();\nvar region = cityFeature.get('region');\nvar Vit = cityFeature.get('Vit');\n\nvar viirsLight = ee.ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')\n  .filterDate(startDate, endDate)\n  .select('avg_rad')\n  .mean()\n  .clip(geometry);\n\n// Average Nighttime Light\nvar meanDN = viirsLight.reduceRegion({\n  reducer: ee.Reducer.mean(),\n  geometry: geometry,\n  scale: 500,\n  maxPixels: 1e9\n}).get('avg_rad');\n\n// Handling missing values\nmeanDN = ee.Algorithms.If(meanDN, meanDN, 0);\nvar logDN = ee.Number(meanDN).log();\n\n// Calculate carbon emissions by region\nvar logNCitj = ee.Algorithms.If(\n  ee.String(region).equals('eastern'),\n  logDN.multiply(1.0484).add(ee.Number(Vit).subtract(6.1871)),\n  ee.Algorithms.If(\n    ee.String(region).equals('central'),\n    logDN.multiply(0.8773).subtract(4.2414),\n    ee.Algorithms.If(\n      ee.String(region).equals('western'),\n      logDN.multiply(0.3645).add(ee.Number(Vit).add(2.2189)),\n      0\n    )\n  )\n);\n\n// Estimating total carbon emissions\n  var NCitj = ee.Number(logNCitj).exp();\n  var cityArea = geometry.area();  // m²\n  var emission = NCitj.multiply(cityArea).divide(250000);  // Ten thousand tons CO₂\n\n  var viirsVis = {        // Visualization\n    min: 0.0,\n    max: 50.0,\n    palette: [\n      'black', 'darkblue', 'blue', 'purple',\n      'cyan', 'green', 'yellow', 'white'\n    ]\n  };\n  \n  var safeDN = viirs.where(viirs.lte(0), 0.1);\n  var logDNimg = safeDN.log();\n\n// Regional coefficient layer\n  var regionStr = ee.String(region);\n  var VitSafe = ee.Algorithms.If(Vit, Vit, 0);\n\n  var a_val = ee.Algorithms.If(\n    regionStr.equals('eastern'), 1.0484,\n    ee.Algorithms.If(regionStr.equals('central'), 0.8773, 0.3645)\n  );\n\n  var b_val = ee.Algorithms.If(\n    regionStr.equals('eastern'), ee.Number(VitSafe).subtract(6.1871),\n    ee.Algorithms.If(regionStr.equals('central'), -4.2414, ee.Number(VitSafe).add(2.2189))\n  );\n\n  var a_img = ee.Image.constant(a_val);\n  var b_img = ee.Image.constant(b_val);\n\n  var logNCitj = logDNimg.multiply(a_img).add(b_img);\n  var emissionImage = logNCitj.exp().multiply(1e10);  \n  var pixelArea = ee.Image.pixelArea();   // Convert units to:(g/m²)\n  emissionImage = emissionImage.divide(pixelArea);  \n\n// Define Carbon Emissions Palette\n  var carbonPalette = [\n    '#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c',\n    '#fc4e2a', '#e31a1c', '#bd0026', '#800026', '#4d0019',\n    '#2b000f', '#67001f', '#99003f', '#b2182b', '#d73027'\n  ];\n\n// Regional visualization scope (g/m²)\n  var visParams = ee.Dictionary({\n    'eastern': {min: 100, max: 3000},\n    'central': {min: 100, max: 4000},\n    'western': {min: 500, max: 5000}\n  });\n\n// NPP/FPAR/Epsilon/WE\n  var dataset = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001')\n    .filterDate(startDate, endDate)\n    .mean()\n    .clip(geometry);\n\n  var rain_temp_par = dataset.expression(\n    'rain * 60 * 60 * 24 * 30', {'rain': dataset.select('Rainf_f_tavg')}\n  ).rename('rain')\n   .addBands(dataset.expression('temp - 273.15', {'temp': dataset.select('Tair_f_tavg')}).rename('temp'))\n   .addBands(dataset.expression('rad * 60 * 60 * 24 * 30 / 1e6 * 0.5', {'rad': dataset.select('Swnet_tavg')}).rename('par'));\n\n  var ndvi = ee.ImageCollection('MODIS/061/MOD13A2')\n    .filterDate(startDate, endDate)\n    .select('NDVI')\n    .mean()\n    .clip(geometry);\n\n  var ndvi_pro = ndvi.multiply(0.0001);\n  var SR = ndvi_pro.add(1).divide(ee.Image(1).subtract(ndvi_pro)).rename('SR');\n\n  var SR_min = SR.reduceRegion({reducer: ee.Reducer.min(), geometry: geometry, scale: 1000}).get('SR');\n  var SR_max = SR.reduceRegion({reducer: ee.Reducer.max(), geometry: geometry, scale: 1000}).get('SR');\n\n  var FPAR = SR.subtract(ee.Number(SR_min)).divide(ee.Number(SR_max).subtract(ee.Number(SR_min))).clamp(0, 0.95).rename('FPAR');\n  var FPAR_filled = FPAR.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(FPAR);\n\n  var evapCollection = ee.ImageCollection(\n    year <= 2020 ? 'MODIS/061/MOD16A2GF' : 'MODIS/061/MOD16A2'\n  );\n\n  var evap = evapCollection\n    .filterDate(startDate, endDate)\n    .mean()\n    .clip(geometry)\n    .select(['ET', 'PET']);\n\n  var WE = evap.expression(\n    '0.5 * ((0.5 + E) / Ep)', {\n      'E': evap.select('ET'),\n      'Ep': evap.select('PET')\n    }).rename('WE');\n\n  var WE_filled = WE.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(WE);\n\n  var T_opt = rain_temp_par.select('temp');\n  var Te1 = ee.Image(0.8).add(T_opt.multiply(0.027)).subtract(T_opt.pow(2).multiply(0.00005)).rename('Te1');\n\n  var Te2 = ee.Image(1.184)\n    .divide(ee.Image(1).add(T_opt.subtract(10).subtract(T_opt).multiply(0.2).exp()))\n    .multiply(ee.Image(1).divide(ee.Image(1).add(T_opt.subtract(10).add(T_opt).multiply(0.3).exp())))\n    .rename('Te2');\n\n  var epsilon = Te1.multiply(Te2).multiply(WE_filled).multiply(0.95).rename('epsilon');\n  var epsilon_filled = epsilon.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(epsilon);\n\n  var common_mask = FPAR_filled.mask()\n    .and(epsilon_filled.mask())\n    .and(WE_filled.mask())\n    .and(rain_temp_par.select('par').mask());\n\n  var par_masked = rain_temp_par.select('par').updateMask(common_mask);\n  var NPP = par_masked.multiply(FPAR_filled).multiply(epsilon_filled).rename('NPP');\n  var CO2_absorption = NPP.multiply(3.6667).rename('CO2_absorption'); // Carbon sequestration CO₂\n  // Calculate net carbon dioxide emissions: carbon dioxide emissions - carbon dioxide sequestration\n  var netEmission = emissionImage.subtract(CO2_absorption).rename('netEmission');\n\n  MyMap.centerObject(geometry, 7);\n```\n\n### **4. Map** Layers\n\nThis section analyzes and displays the calculated results in a layered format, including nighttime light intensity, CO₂ emissions, CO₂ sequestration , net CO₂ emissions, NPP, WE, FPAR, and Epsilon. Users can switch between different indicator layers with one click through the interface, intuitively observing the spatial distribution characteristics and differences of CO₂ emissions and sequestration .\n\nNote: In the color matching design of the **Carbon Sequestration CO₂ layer**, a segmented color matching strategy combined with gradient color depth was adopted. Specifically, different color segments (orange-blue-green) are used to quickly distinguish the overall level of carbon sequestration; The gradient inside each color segment is further subdivided into intensity changes, allowing users to accurately perceive differences within the same level. In the **Net CO₂ emissions layer**, cool colors (green series) are used to represent carbon sequestration, warm colors (yellow to red series) are used to represent carbon emissions, and white is used as a bidirectional symmetrical color band structure with zero emissions, intuitively showing whether the city is a carbon source or sink.\n\n``` JavaScript\n// =========== Add Layer ==============\n// WE Layer\n  MyMap.addLayer(WE_filled.updateMask(common_mask), {min: 0, max: 1, palette: ['white', 'blue']}, 'WE');\n  allLegendPanel.add(createLegendBox('WE', ['white', 'blue'], 0, 1));\n\n// NPP Layer\n  MyMap.addLayer(NPP, {\n  min: 0,\n  max: 10,\n  palette: [\n    // 0 = white\n    '#ffffff',\n\n    // >0–3：Orange → Deep Red, Level 10 Gradient\n    '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548',\n    '#d7301f', '#c1271a', '#bd0026', '#99000d', '#67000d',\n\n    // 3–6：Blue → Purple\n    '#deebf7', '#9ecae1', '#3182bd', '#6a51a3', '#54278f',\n\n    // 6–10：Light green → Dark green\n    '#e5f5e0', '#a1d99b', '#31a354', '#006d2c'\n  ]\n}, 'NPP');\n  allLegendPanel.add(createLegendBox('NPP (gC/m²)', [\n    '#ffffff',\n    '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548',\n    '#d7301f', '#c1271a', '#bd0026', '#99000d', '#67000d',\n    '#deebf7', '#9ecae1', '#3182bd', '#6a51a3', '#54278f',\n    '#e5f5e0', '#a1d99b', '#31a354', '#006d2c'\n  ], 0, 10));\n  \n// NPP layer projection information\n  updateStatus('Carbon dioxide sequestration layer projection:', CO2_absorption.projection());\n  updateStatus('Carbon dioxide sequestration layer nominal scale (m):', CO2_absorption.projection().nominalScale());\n  updateStatus('Carbon dioxide emission layer projection:', emissionImage.projection());\n  updateStatus('Carbon dioxide emission layer nominal scale (m):', emissionImage.projection().nominalScale());\n\n// Epsilon Layer\n  MyMap.addLayer(epsilon_filled.updateMask(common_mask), {min: 0, max: 0.5, palette: ['purple', 'blue', 'green']}, 'Epsilon');\n  allLegendPanel.add(createLegendBox('Epsilon', ['purple', 'blue', 'green'], 0, 0.5));\n\n// FPAR Layer\n  MyMap.addLayer(FPAR_filled.updateMask(common_mask), {min: 0, max: 0.95, palette: ['yellow', 'orange', 'red']}, 'FPAR');\n  allLegendPanel.add(createLegendBox('FPAR', ['yellow', 'orange', 'red'], 0, 0.95));\n\n// Nighttime Light Layer\n  MyMap.addLayer(viirs, viirsVis, 'Night-time Lights');\n  allLegendPanel.add(createLegendBox('Nighttime light intensity', viirsVis.palette, viirsVis.min, viirsVis.max));\n\n// Carbon sequestration CO₂ Layer\nMyMap.addLayer(CO2_absorption, {\n  min: 0,\n  max: 30,   \n  palette: [\n    // 0 = white\n    '#ffffff',\n\n    // >0–3：Orange → Deep Red, Level 10 Gradient\n    '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548',\n    '#d7301f', '#c1271a', '#bd0026', '#99000d', '#67000d',\n\n    // 3–6：Blue → Purple\n    '#deebf7', '#9ecae1', '#3182bd', '#6a51a3', '#54278f',\n\n    // 6–10：Light green → Dark green\n    '#e5f5e0', '#a1d99b', '#31a354', '#006d2c'\n  ]\n}, 'Carbon sequestration (CO₂)');\n  allLegendPanel.add(createLegendBox('Carbon sequestration (CO₂)', [\n    '#ffffff',\n    '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548',\n    '#d7301f', '#c1271a', '#bd0026', '#99000d', '#67000d',\n    '#deebf7', '#9ecae1', '#3182bd', '#6a51a3', '#54278f',\n    '#e5f5e0', '#a1d99b', '#31a354', '#006d2c'\n  ], 0, 30));\n\n// CO₂ Emissions Layer\n  var selectedVis = visParams.get(regionStr).getInfo();\n\n  MyMap.addLayer(emissionImage, {\n    min: selectedVis.min,\n    max: selectedVis.max,\n    palette: carbonPalette\n  }, 'Carbon Emissions (CO₂)'); //(g/m²)\n  allLegendPanel.add(createLegendBox('Carbon Emissions (CO₂)', carbonPalette, selectedVis.min, selectedVis.max));\n\n// Net carbon dioxide emission layer\n  var netEmissionPalette = [\n    '#e5f5e0', '#a1d99b', '#31a354', '#006d2c',  // Negative value (sequestration)\n    '#ffffff',                                   // 0 (white)\n    '#ffffcc', '#ffeda0', '#fed976', '#feb24c',  // Positive value (Light emissions)\n    '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'  // Positive value (Heavy emissions)\n  ];\n    \n  MyMap.addLayer(netEmission, {\n    min: -50,\n    max: 200,\n    palette: netEmissionPalette\n  }, 'Net CO₂ emissions (g/m²)');\n  allLegendPanel.add(createLegendBox('Net CO₂ emissions (g/m²)', netEmissionPalette, -50, 200));\n}\n```\n\n### **5.** Chart Drawing\n\nThis section presents line charts of monthly CO₂ emissions, CO₂ sequestration, and net CO₂ emissions trends at different spatial scales (cities, provinces, urban agglomerations) over a year. In addition, the researchers also add a pie chart of the proportion of net CO₂ emissions of cities in urban agglomerations.\n\n``` JavaScript\n// =============== Line Chart Visualization ================\n\n// figure1: average values of each indicator in cities\nfunction plotCityIndicatorChart(cityName, geometry, year, indicator) {\n  indicator = indicator || 'NPP';\nvar months = ee.List.sequence(1, 12);\n\n  var cityArea = geometry.area();\n\n  var cityFeature = matchedCities.filterBounds(geometry).first();\n  var region = cityFeature.get('region');\n  var Vit = cityFeature.get('Vit');\n\n  var monthlyData = months.map(function(m) {\n    var start = ee.Date.fromYMD(year, m, 1);\n    var end = start.advance(1, 'month');\n\n    var fldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001')\n      .filterDate(start, end)\n      .first()\n      .clip(geometry);\n\n    var ndvi = ee.ImageCollection('MODIS/061/MOD13A2')\n      .filterDate(start, end)\n      .select('NDVI')\n      .first()\n      .clip(geometry);\n\n    var nightLight = ee.ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')\n      .filterDate(start, end)\n      .first()\n      .clip(geometry);\n\n    var evapCollection = ee.ImageCollection(\n      year <= 2020 ? 'MODIS/061/MOD16A2GF' : 'MODIS/061/MOD16A2'\n    );\n    var evap = evapCollection\n      .filterDate(start, end)\n      .first()\n      .clip(geometry);\n\n    return ee.Algorithms.If(fldas && ndvi && nightLight && evap, (function() {\n      var rain_temp_par = fldas.expression(\n        'rain * 60 * 60 * 24 * 30', {'rain': fldas.select('Rainf_f_tavg')}\n      ).rename('rain')\n        .addBands(fldas.expression('temp - 273.15', {'temp': fldas.select('Tair_f_tavg')}).rename('temp'))\n        .addBands(fldas.expression('rad * 60 * 60 * 24 * 30 / 1e6 * 0.5', {'rad': fldas.select('Swnet_tavg')}).rename('par'));\n\n      var ndvi_pro = ndvi.multiply(0.0001);\n      var SR = ndvi_pro.add(1).divide(ee.Image(1).subtract(ndvi_pro)).rename('SR');\n\n      var SR_min = SR.reduceRegion({reducer: ee.Reducer.min(), geometry: geometry, scale: 1000}).get('SR');\n      var SR_max = SR.reduceRegion({reducer: ee.Reducer.max(), geometry: geometry, scale: 1000}).get('SR');\n\n      var FPAR = SR.subtract(ee.Number(SR_min))\n        .divide(ee.Number(SR_max).subtract(ee.Number(SR_min)))\n        .clamp(0, 0.95)\n        .rename('FPAR');\n      var FPAR_filled = FPAR.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(FPAR);\n\n      var WE = evap.expression(\n        '0.5 * ((0.5 + E) / Ep)', {\n          'E': evap.select('ET'),\n          'Ep': evap.select('PET')\n        }).rename('WE');\n      var WE_filled = WE.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(WE);\n\n      var T_opt = rain_temp_par.select('temp');\n      var Te1 = ee.Image(0.8).add(T_opt.multiply(0.027)).subtract(T_opt.pow(2).multiply(0.00005));\n      var Te2 = ee.Image(1.184)\n        .divide(ee.Image(1).add(T_opt.subtract(10).subtract(T_opt).multiply(0.2).exp()))\n        .multiply(ee.Image(1).divide(ee.Image(1).add(T_opt.subtract(10).add(T_opt).multiply(0.3).exp())));\n\n      var epsilon = Te1.multiply(Te2).multiply(WE_filled).multiply(0.95);\n      var epsilon_filled = epsilon.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(epsilon);\n\n      var common_mask = FPAR_filled.mask()\n        .and(epsilon_filled.mask())\n        .and(WE_filled.mask())\n        .and(rain_temp_par.select('par').mask());\n\n      var par_masked = rain_temp_par.select('par').updateMask(common_mask);\n      var NPP = par_masked.multiply(FPAR_filled).multiply(epsilon_filled).rename('NPP');\n\n      var safeDN = nightLight.select('avg_rad').where(nightLight.select('avg_rad').lte(0), 0.1);\n      var logDNimg = safeDN.log();\n\n      var regionStr = ee.String(region);\n      var VitSafe = ee.Algorithms.If(Vit, Vit, 0);\n\n      var a_val = ee.Algorithms.If(\n        regionStr.equals('eastern'), 1.0484,\n        ee.Algorithms.If(regionStr.equals('central'), 0.8773, 0.3645)\n      );\n\n      var b_val = ee.Algorithms.If(\n        regionStr.equals('eastern'), ee.Number(VitSafe).subtract(6.1871),\n        ee.Algorithms.If(regionStr.equals('central'), -4.2414, ee.Number(VitSafe).add(2.2189))\n      );\n\n      var a_img = ee.Image.constant(a_val);\n      var b_img = ee.Image.constant(b_val);\n\n      var logNCitj = logDNimg.multiply(a_img).add(b_img);\n      var emissionImage = logNCitj.exp().multiply(1e10).divide(ee.Image.pixelArea());\n\n      var CO2_absorption = NPP.multiply(3.6667).rename('CO2_absorption');\n\n      var targetImage = ee.Image(0);\n\n      if (indicator === 'NPP') {\n        targetImage = NPP;\n      } else if (indicator === 'WE') {\n        targetImage = WE_filled;\n      } else if (indicator === 'FPAR') {\n        targetImage = FPAR_filled;\n      } else if (indicator === 'Epsilon') {\n        targetImage = epsilon_filled;\n      } else if (indicator === 'Emission') {\n        targetImage = emissionImage;\n      } else if (indicator === 'CO2Absorption') {\n        targetImage = CO2_absorption;\n      } else if (indicator === 'Rain') {\n        targetImage = rain_temp_par.select('rain');\n      } else if (indicator === 'Temperature') {\n        targetImage = rain_temp_par.select('temp');\n      } else if (indicator === 'PAR') {\n        targetImage = rain_temp_par.select('par');\n      }\n\n      var meanValue = targetImage.reduceRegion({\n        reducer: ee.Reducer.mean(),\n        geometry: geometry,\n        scale: 1000,\n        maxPixels: 1e9\n      }).values().get(0);\n\nmeanValue = ee.Algorithms.If(meanValue, meanValue, 0);\n\n      return ee.Feature(null, {\n        'month': m,\n        'value': meanValue,\n        'city': cityName\n      });\n\n    })(), null);\n  });\n\n  var featureCol = ee.FeatureCollection(monthlyData)\n    .filter(ee.Filter.notNull(['value']))\n    .sort('month');\n  \n  var indicatorUnits = {\n  'NPP': 'gC/m²',\n  'WE': '',\n  'FPAR': '',\n  'Epsilon': '', \n  'Emission': 'gCO₂/m²',\n  'CO2Absorption': 'gCO₂/m²',\n  'Rain': 'mm/month',\n  'Temperature': '°C',\n  'PAR': 'MJ/m²/month'\n    \n  };\n\n  \n  var unit = indicatorUnits[indicator] || '';\n\n  var chart = ui.Chart.feature.byFeature(featureCol, 'month', 'value')\n    .setChartType('LineChart')\n    .setOptions({\n      title:   'Monthly Average Values of '+ indicator + '\\n' + cityName + '（' + year + '）',\n      hAxis: {title: 'month'},\n      vAxis: {title: 'Average Values of'+ indicator + unit},\n      lineWidth: 2,\n      pointSize: 4,\n      height: 152,\n      legend: {position: 'none'}\n    });\n\n  chartPanel.add(chart);\nreturn chart;\n}\n\n\n// figure2: Total carbon emisssions,sequestration,netemisssions amount in agglomerations (10ktons CO₂)\nfunction plotUrbanAgglomerationCarbonChart(urbanAggName, geometry, year) {\n  var months = ee.List.sequence(1, 12);\n  var cityArea = geometry.area();\n\n  var sampleCity = matchedCities.filter(ee.Filter.eq('UrbanAgg', urbanAggName)).first();\n  var region = sampleCity.get('region');\n  var Vit = sampleCity.get('Vit');\n\n  var monthly = months.map(function(m) {\n    var start = ee.Date.fromYMD(year, m, 1);\n    var end = start.advance(1, 'month');\n\n    var nightLight = dataset.filterDate(start, end).mean().clip(geometry);\n    var fldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001')\n      .filterDate(start, end).first();\n    var ndvi = ee.ImageCollection('MODIS/061/MOD13A2')\n      .filterDate(start, end).select('NDVI').first();\n    var evapCollection = ee.ImageCollection(\n      year <= 2020 ? 'MODIS/061/MOD16A2GF' : 'MODIS/061/MOD16A2'\n    );\n    var evap = evapCollection.filterDate(start, end).first();\n\n    return ee.Algorithms.If(nightLight && fldas && ndvi && evap, (function() {\n      var meanDN = nightLight.select('avg_rad').reduceRegion({\n        reducer: ee.Reducer.mean(),\n        geometry: geometry,\n        scale: 500,\n        maxPixels: 1e9\n      }).get('avg_rad');\n      meanDN = ee.Algorithms.If(meanDN, meanDN, 0);\n      var logDN = ee.Number(meanDN).log();\n      var logNCitj = ee.Algorithms.If(\n        ee.String(region).equals('eastern'),\n        logDN.multiply(1.0484).add(ee.Number(Vit).subtract(6.1871)),\n        ee.Algorithms.If(\n          ee.String(region).equals('central'),\n          logDN.multiply(0.8773).subtract(4.2414),\n          ee.Algorithms.If(\n            ee.String(region).equals('western'),\n            logDN.multiply(0.3645).add(ee.Number(Vit).add(2.2189)),\n            0\n          )\n        )\n      );\n      var NCitj = ee.Number(logNCitj).exp();\n      var emission = NCitj.multiply(cityArea).divide(250000);\n\n      var rain_temp_par = fldas.expression(\n        'rain * 60 * 60 * 24 * 30', {'rain': fldas.select('Rainf_f_tavg')}\n      ).rename('rain')\n        .addBands(fldas.expression('temp - 273.15', {'temp': fldas.select('Tair_f_tavg')}).rename('temp'))\n        .addBands(fldas.expression('rad * 60 * 60 * 24 * 30 / 1e6 * 0.5', {'rad': fldas.select('Swnet_tavg')}).rename('par'));\n\n      var ndvi_pro = ndvi.multiply(0.0001);\n      var SR = ndvi_pro.add(1).divide(ee.Image(1).subtract(ndvi_pro)).rename('SR');\n\n      var SR_min = SR.reduceRegion({reducer: ee.Reducer.min(), geometry: geometry, scale: 1000}).get('SR');\n      var SR_max = SR.reduceRegion({reducer: ee.Reducer.max(), geometry: geometry, scale: 1000}).get('SR');\n\n      var FPAR = SR.subtract(ee.Number(SR_min)).divide(ee.Number(SR_max).subtract(ee.Number(SR_min))).clamp(0, 0.95);\n      var FPAR_filled = FPAR.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(FPAR);\n\n      var WE = evap.expression(\n        '0.5 * ((0.5 + E) / Ep)', {\n          'E': evap.select('ET'),\n          'Ep': evap.select('PET')\n        }).rename('WE');\n      var WE_filled = WE.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(WE);\n\n      var T_opt = rain_temp_par.select('temp');\n      var Te1 = ee.Image(0.8).add(T_opt.multiply(0.027)).subtract(T_opt.pow(2).multiply(0.00005));\n      var Te2 = ee.Image(1.184)\n        .divide(ee.Image(1).add(T_opt.subtract(10).subtract(T_opt).multiply(0.2).exp()))\n        .multiply(ee.Image(1).divide(ee.Image(1).add(T_opt.subtract(10).add(T_opt).multiply(0.3).exp())));\n\n      var epsilon = Te1.multiply(Te2).multiply(WE_filled).multiply(0.95);\n      var epsilon_filled = epsilon.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(epsilon);\n\n      var common_mask = FPAR_filled.mask()\n        .and(epsilon_filled.mask())\n        .and(WE_filled.mask())\n        .and(rain_temp_par.select('par').mask());\n\n      var par_masked = rain_temp_par.select('par').updateMask(common_mask);\n      var NPP = par_masked.multiply(FPAR_filled).multiply(epsilon_filled).rename('NPP');\n\n      var meanNPP = NPP.reduceRegion({\n        reducer: ee.Reducer.mean(),\n        geometry: geometry,\n        scale: 1000,\n        maxPixels: 1e9\n      }).get('NPP');\n\n      var totalCarbon_g = ee.Number(meanNPP).multiply(cityArea);\n      var totalCO2_g = totalCarbon_g.multiply(44).divide(12);\n      var totalCO2_kt = totalCO2_g.divide(1e8);\n\n      var netEmission = emission.subtract(totalCO2_kt);\n\n      return ee.Feature(null, {\n        'month': m,\n        'emission': emission,\n        'sequestration': totalCO2_kt,\n        'netEmission': netEmission\n      });\n    })(), null);\n  });\n\n  var fc = ee.FeatureCollection(monthly)\n    .filter(ee.Filter.notNull(['emission']))\n    .sort('month');\n\n  var chart = ui.Chart.feature.byFeature(fc, 'month', ['emission', 'sequestration', 'netEmission'])\n    .setChartType('LineChart')\n    .setOptions({\n      title: 'Monthly Carbon Emission / Sequestration / Net Emission\\n' + urbanAggName + '（' + year + '）',\n      hAxis: {title: 'Month'},\n      vAxis: {title: 'Amount (10ktons CO₂)'},\n      lineWidth: 2,\n      pointSize: 4,\n      height: 300,\n      legend: {position: 'bottom'}\n    });\n\n  chartPanel.add(chart);\n}\n\n// figure3: Total carbon emisssions,sequestration,netemisssions amount in provinces (10ktons CO₂)\nfunction plotProvinceCarbonChart(provinceName, geometry, year) {\n  var months = ee.List.sequence(1, 12);\n  var cityArea = geometry.area();\n\n  var sampleCity = matchedCities.filter(ee.Filter.eq('NAME_1', provinceName)).first();\n  var region = sampleCity.get('region');\n  var Vit = sampleCity.get('Vit');\n\n  var monthly = months.map(function(m) {\n    var start = ee.Date.fromYMD(year, m, 1);\n    var end = start.advance(1, 'month');\n\n    var nightLight = dataset.filterDate(start, end).mean().clip(geometry);\n    var fldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001')\n      .filterDate(start, end).first();\n    var ndvi = ee.ImageCollection('MODIS/061/MOD13A2')\n      .filterDate(start, end).select('NDVI').first();\n    var evapCollection = ee.ImageCollection(\n      year <= 2020 ? 'MODIS/061/MOD16A2GF' : 'MODIS/061/MOD16A2'\n    );\n    var evap = evapCollection.filterDate(start, end).first();\n\n    return ee.Algorithms.If(nightLight && fldas && ndvi && evap, (function() {\n      var meanDN = nightLight.select('avg_rad').reduceRegion({\n        reducer: ee.Reducer.mean(),\n        geometry: geometry,\n        scale: 500,\n        maxPixels: 1e9\n      }).get('avg_rad');\n      meanDN = ee.Algorithms.If(meanDN, meanDN, 0);\n      var logDN = ee.Number(meanDN).log();\n      var logNCitj = ee.Algorithms.If(\n        ee.String(region).equals('eastern'),\n        logDN.multiply(1.0484).add(ee.Number(Vit).subtract(6.1871)),\n        ee.Algorithms.If(\n          ee.String(region).equals('central'),\n          logDN.multiply(0.8773).subtract(4.2414),\n          ee.Algorithms.If(\n            ee.String(region).equals('western'),\n            logDN.multiply(0.3645).add(ee.Number(Vit).add(2.2189)),\n            0\n          )\n        )\n      );\n      var NCitj = ee.Number(logNCitj).exp();\n      var emission = NCitj.multiply(cityArea).divide(250000);\n\n      var rain_temp_par = fldas.expression(\n        'rain * 60 * 60 * 24 * 30', {'rain': fldas.select('Rainf_f_tavg')}\n      ).rename('rain')\n        .addBands(fldas.expression('temp - 273.15', {'temp': fldas.select('Tair_f_tavg')}).rename('temp'))\n        .addBands(fldas.expression('rad * 60 * 60 * 24 * 30 / 1e6 * 0.5', {'rad': fldas.select('Swnet_tavg')}).rename('par'));\n\n      var ndvi_pro = ndvi.multiply(0.0001);\n      var SR = ndvi_pro.add(1).divide(ee.Image(1).subtract(ndvi_pro)).rename('SR');\n\n      var SR_min = SR.reduceRegion({reducer: ee.Reducer.min(), geometry: geometry, scale: 1000}).get('SR');\n      var SR_max = SR.reduceRegion({reducer: ee.Reducer.max(), geometry: geometry, scale: 1000}).get('SR');\n\n      var FPAR = SR.subtract(ee.Number(SR_min)).divide(ee.Number(SR_max).subtract(ee.Number(SR_min))).clamp(0, 0.95);\n      var FPAR_filled = FPAR.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(FPAR);\n\n      var WE = evap.expression(\n        '0.5 * ((0.5 + E) / Ep)', {\n          'E': evap.select('ET'),\n          'Ep': evap.select('PET')\n        }).rename('WE');\n      var WE_filled = WE.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(WE);\n\n      var T_opt = rain_temp_par.select('temp');\n      var Te1 = ee.Image(0.8).add(T_opt.multiply(0.027)).subtract(T_opt.pow(2).multiply(0.00005));\n      var Te2 = ee.Image(1.184)\n        .divide(ee.Image(1).add(T_opt.subtract(10).subtract(T_opt).multiply(0.2).exp()))\n        .multiply(ee.Image(1).divide(ee.Image(1).add(T_opt.subtract(10).add(T_opt).multiply(0.3).exp())));\n\n      var epsilon = Te1.multiply(Te2).multiply(WE_filled).multiply(0.95);\n      var epsilon_filled = epsilon.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(epsilon);\n\n      var common_mask = FPAR_filled.mask()\n        .and(epsilon_filled.mask())\n        .and(WE_filled.mask())\n        .and(rain_temp_par.select('par').mask());\n\n      var par_masked = rain_temp_par.select('par').updateMask(common_mask);\n      var NPP = par_masked.multiply(FPAR_filled).multiply(epsilon_filled).rename('NPP');\n\n      var meanNPP = NPP.reduceRegion({\n        reducer: ee.Reducer.mean(),\n        geometry: geometry,\n        scale: 1000,\n        maxPixels: 1e9\n      }).get('NPP');\n\n      var totalCarbon_g = ee.Number(meanNPP).multiply(cityArea);\n      var totalCO2_g = totalCarbon_g.multiply(44).divide(12);\n      var totalCO2_kt = totalCO2_g.divide(1e8);\n\n      var netEmission = emission.subtract(totalCO2_kt);\n\n      return ee.Feature(null, {\n        'month': m,\n        'emission': emission,\n        'sequestration': totalCO2_kt,\n        'netEmission': netEmission\n      });\n    })(), null);\n  });\n\n  var fc = ee.FeatureCollection(monthly)\n    .filter(ee.Filter.notNull(['emission']))\n    .sort('month');\n\n  var chart = ui.Chart.feature.byFeature(fc, 'month', ['emission', 'sequestration', 'netEmission'])\n    .setChartType('LineChart')\n    .setOptions({\n      title: 'Monthly Carbon Emission / Sequestration / Net Emission\\n' + provinceName + '（' + year + '）',\n      hAxis: {title: 'Month'},\n      vAxis: {title: 'Amount (10ktons CO₂)'},\n      lineWidth: 2,\n      pointSize: 4,\n      height: 300,\n      legend: {position: 'bottom'}\n    });\n\n  chartPanel.add(chart);\n}\n\n// figure4: Total carbon emisssions,sequestration,netemisssions amount in cities (10ktons CO₂)\nfunction plotSinglecityCarbonChart(cityName, geometry, year) {\n  return new Promise(function(resolve, reject) {\n    var months = ee.List.sequence(1, 12);\n    var cityArea = geometry.area();\n    var cityFeature = matchedCities.filterBounds(geometry).first();\n    var region = cityFeature.get('region');\n    var Vit = cityFeature.get('Vit');\n\n    var monthly = months.map(function(m) {\n      var start = ee.Date.fromYMD(year, m, 1);\n      var end = start.advance(1, 'month');\n\n      var nightLight = dataset.filterDate(start, end).mean().clip(geometry);\n      var fldas = ee.ImageCollection('NASA/FLDAS/NOAH01/C/GL/M/V001').filterDate(start, end).first();\n      var ndvi = ee.ImageCollection('MODIS/061/MOD13A2').filterDate(start, end).select('NDVI').first();\n      var evapCollection = ee.ImageCollection(year <= 2020 ? 'MODIS/061/MOD16A2GF' : 'MODIS/061/MOD16A2');\n      var evap = evapCollection.filterDate(start, end).first();\n\n      return ee.Algorithms.If(nightLight && fldas && ndvi && evap, (function() {\n        var meanDN = nightLight.select('avg_rad').reduceRegion({\n          reducer: ee.Reducer.mean(),\n          geometry: geometry,\n          scale: 500,\n          maxPixels: 1e9\n        }).get('avg_rad');\n        meanDN = ee.Algorithms.If(meanDN, meanDN, 0);\n        var logDN = ee.Number(meanDN).log();\n\n        var logNCitj = ee.Algorithms.If(\n          ee.String(region).equals('eastern'),\n          logDN.multiply(1.0484).add(ee.Number(Vit).subtract(6.1871)),\n          ee.Algorithms.If(\n            ee.String(region).equals('central'),\n            logDN.multiply(0.8773).subtract(4.2414),\n            logDN.multiply(0.3645).add(ee.Number(Vit).add(2.2189))\n          )\n        );\n\n        var NCitj = ee.Number(logNCitj).exp();\n        var emission = NCitj.multiply(cityArea).divide(250000);\n\n        var rain_temp_par = fldas.expression(\n          'rain * 60 * 60 * 24 * 30', {'rain': fldas.select('Rainf_f_tavg')}\n        ).rename('rain')\n          .addBands(fldas.expression('temp - 273.15', {'temp': fldas.select('Tair_f_tavg')}).rename('temp'))\n          .addBands(fldas.expression('rad * 60 * 60 * 24 * 30 / 1e6 * 0.5', {'rad': fldas.select('Swnet_tavg')}).rename('par'));\n\n        var ndvi_pro = ndvi.multiply(0.0001);\n        var SR = ndvi_pro.add(1).divide(ee.Image(1).subtract(ndvi_pro)).rename('SR');\n\n        var SR_min = SR.reduceRegion({reducer: ee.Reducer.min(), geometry: geometry, scale: 1000}).get('SR');\n        var SR_max = SR.reduceRegion({reducer: ee.Reducer.max(), geometry: geometry, scale: 1000}).get('SR');\n\n        var FPAR = SR.subtract(ee.Number(SR_min)).divide(ee.Number(SR_max).subtract(ee.Number(SR_min))).clamp(0, 0.95);\n        var FPAR_filled = FPAR.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(FPAR);\n\n        var WE = evap.expression(\n          '0.5 * ((0.5 + E) / Ep)', {\n            'E': evap.select('ET'),\n            'Ep': evap.select('PET')\n          }).rename('WE');\n        var WE_filled = WE.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(WE);\n\n        var T_opt = rain_temp_par.select('temp');\n        var Te1 = ee.Image(0.8).add(T_opt.multiply(0.027)).subtract(T_opt.pow(2).multiply(0.00005));\n        var Te2 = ee.Image(1.184)\n          .divide(ee.Image(1).add(T_opt.subtract(10).subtract(T_opt).multiply(0.2).exp()))\n          .multiply(ee.Image(1).divide(ee.Image(1).add(T_opt.subtract(10).add(T_opt).multiply(0.3).exp())));\n\n        var epsilon = Te1.multiply(Te2).multiply(WE_filled).multiply(0.95);\n        var epsilon_filled = epsilon.unmask().focal_mean({radius: 1, units: 'pixels'}).blend(epsilon);\n\n        var common_mask = FPAR_filled.mask().and(epsilon_filled.mask()).and(WE_filled.mask()).and(rain_temp_par.select('par').mask());\n        var par_masked = rain_temp_par.select('par').updateMask(common_mask);\n\n        var NPP = par_masked.multiply(FPAR_filled).multiply(epsilon_filled).rename('NPP');\n\n        var meanNPP = NPP.reduceRegion({\n          reducer: ee.Reducer.mean(),\n          geometry: geometry,\n          scale: 1000,\n          maxPixels: 1e9\n        }).get('NPP');\n\n        var totalCarbon_g = ee.Number(meanNPP).multiply(cityArea);\n        var totalCO2_g = totalCarbon_g.multiply(44).divide(12);\n        var totalCO2_kt = totalCO2_g.divide(1e8);\n\n        var netEmission = emission.subtract(totalCO2_kt);\n\n        return ee.FeatureCollection([\n          ee.Feature(null, {'month': m, 'value': totalCO2_kt, 'type': 'Sequestration'}),\n          ee.Feature(null, {'month': m, 'value': emission, 'type': 'Emission'}),\n          ee.Feature(null, {'month': m, 'value': netEmission, 'type': 'NetEmission'})\n        ]);\n      })(), null);\n    });\n\n    var fc = ee.FeatureCollection(monthly).flatten();\n\n    var chart = ui.Chart.feature.groups({\n      features: fc,\n      xProperty: 'month',\n      yProperty: 'value',\n      seriesProperty: 'type'\n    })\n    .setChartType('LineChart')\n    .setOptions({\n      title: 'Monthly Carbon Sequestration / Emissions / Net Emissions\\n' + cityName + ' (' + year + ')',\n      hAxis: {title: 'Month'},\n      vAxis: {title: 'Amount (10ktons CO₂)'},\n      lineWidth: 2,\n      pointSize: 4,\n      height: 300,\n      legend: {position: 'bottom'}\n    });\n\n    chartPanel.add(chart);\n\n    var annualNetEmission = fc.filter(ee.Filter.eq('type', 'NetEmission'))\n      .aggregate_sum('value');\n\n    annualNetEmission.evaluate(function(netEmissionValue) {\n      if (netEmissionValue < 0) {\n        chartPanel.add(ui.Label('This city\\'s annual net CO₂ emissions are less than zero, indicating a carbon sink city.'));\n        resolve();\n      } else {\n        var cityFeature = matchedCities.filter(ee.Filter.eq('NAME_2', cityName)).first();\n        var urbanAgg = cityFeature.get('UrbanAgg');\n        var urbanAggCities = matchedCities.filter(ee.Filter.eq('UrbanAgg', urbanAgg));\n        var urbanAggGeom = urbanAggCities.geometry();\n        var sampleRegion = cityFeature.get('region');\n        var sampleVit = cityFeature.get('Vit');\n\n        var urbanAggMonthly = months.map(function(m) {\n          var start = ee.Date.fromYMD(year, m, 1);\n          var end = start.advance(1, 'month');\n\n          var nightLight = dataset.filterDate(start, end).mean().clip(urbanAggGeom);\n          var meanDN = nightLight.select('avg_rad').reduceRegion({\n            reducer: ee.Reducer.mean(),\n            geometry: urbanAggGeom,\n            scale: 500,\n            maxPixels: 1e9\n          }).get('avg_rad');\n\n          meanDN = ee.Algorithms.If(meanDN, meanDN, 0);\n          var logDN = ee.Number(meanDN).log();\n          var logNCitj = ee.Algorithms.If(\n            ee.String(sampleRegion).equals('eastern'),\n            logDN.multiply(1.0484).add(ee.Number(sampleVit).subtract(6.1871)),\n            ee.Algorithms.If(\n              ee.String(sampleRegion).equals('central'),\n              logDN.multiply(0.8773).subtract(4.2414),\n              logDN.multiply(0.3645).add(ee.Number(sampleVit).add(2.2189))\n            )\n          );\n          var NCitj = ee.Number(logNCitj).exp();\n          var aggArea = urbanAggGeom.area();\n          var totalEmission = NCitj.multiply(aggArea).divide(250000);\n          return totalEmission;\n        });\n\n        var annualUrbanAggNetEmission = ee.Number(urbanAggMonthly.reduce(ee.Reducer.sum()));\n        var cityEmission = ee.Number(netEmissionValue);\n        var restEmission = annualUrbanAggNetEmission.subtract(cityEmission);\n\n        var pieData = ee.FeatureCollection([\n          ee.Feature(null, {'category': cityName, 'emission': cityEmission}),\n          ee.Feature(null, {'category': 'Rest of ' + urbanAgg.getInfo(), 'emission': restEmission})\n        ]);\n\n        var pieChart = ui.Chart.feature.byFeature(pieData, 'category', 'emission')\n          .setChartType('PieChart')\n          .setOptions({\n            title: 'Annual Net CO₂ Emissions Comparison (10ktons):\\nCity vs Rest of Urban Agglomeration',\n            sliceVisibilityThreshold: 0,\n            legend: {position: 'right'},\n            pieSliceText: 'percentage',\n            height: 280\n          });\n\n        chartPanel.add(pieChart);\n        resolve();\n      }\n    });\n  });\n}\n```\n\n## Bibliography\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"monokai.theme","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.29","book":{"title":"CASA0025 Final Assessment","author":"Group Name","date":"01/01/2024","chapters":["index.qmd"],"repo-actions":["edit"],"downloads":["pdf","epub"],"sharing":["twitter","facebook"],"favicon":"favicon.ico","sidebar":{"logo":"casa_logo.png"}},"theme":{"dark":"darkly","light":"cosmo"},"code-copy":true,"linkcolor":"#34a832","title":"CASA0025 Interactive Application","author":"Zixing Guan, Ruoyun Yu, Siyi Li","date":"2025-04-25","bibliography":["25references.bib"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}